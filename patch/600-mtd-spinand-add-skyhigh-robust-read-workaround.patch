From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: XG-040G-MD <xg040gmd@local>
Date: Mon, 17 Feb 2025 00:00:00 +0800
Subject: [PATCH] mtd: spinand: add SkyHigh robust read workaround

SkyHigh SPI-NAND flash chips (MFR ID: 0x01) may return a false READY
signal on the first status register poll after a page read. If the host
immediately reads data from the cache, the internal buffer may not be
fully ready, leading to "dirty data" and ECC errors (perceived as bit
flips).

According to SkyHigh's "Robust Read Method" documentation, two
consecutive reads of the status register are required. Only when both
reads show Bit 0 (BUSY) as 0 is the device truly ready.

This patch adds a double-check of the status register after
spinand_wait() returns for SkyHigh chips. A 10us delay is inserted
before re-reading the status. If the second read still shows BUSY, the
full wait loop is re-entered.

Signed-off-by: XG-040G-MD <xg040gmd@local>
---
 drivers/mtd/nand/spi/core.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

--- a/drivers/mtd/nand/spi/core.c
+++ b/drivers/mtd/nand/spi/core.c
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/spi-mem.h>
+#include <linux/delay.h>
 
 static int spinand_read_reg_op(struct spinand_device *spinand, u8 reg, u8 *val)
 {
@@ -554,6 +555,22 @@ static int spinand_read_page(struct spin
 	if (ret < 0)
 		return ret;
 
+	/*
+	 * SkyHigh SPI-NAND Robust Read workaround:
+	 * The first READY signal may be false. Re-check the status register
+	 * after a short delay. If still busy, re-enter the wait loop.
+	 */
+	if (spinand->id.data[0] == 0x01) {
+		udelay(10);
+		ret = spinand_read_status(spinand, &status);
+		if (ret)
+			return ret;
+		if (status & STATUS_BUSY) {
+			ret = spinand_wait(spinand, 0, SPINAND_READ_POLL_DELAY_US, &status);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
 	spinand_ondie_ecc_save_status(nand, status);
 
 	ret = spinand_read_from_cache_op(spinand, req);
